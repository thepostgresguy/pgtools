#!/bin/bash
#
# Script: grafana_dashboard_generator.sh
# Purpose: Generate Grafana dashboards for PostgreSQL monitoring
# Usage: ./integration/grafana_dashboard_generator.sh [OPTIONS]
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PGTOOLS_ROOT="$(dirname "$SCRIPT_DIR")"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "[$(date '+%H:%M:%S')] ${BLUE}INFO${NC} $*"; }
warn() { echo -e "[$(date '+%H:%M:%S')] ${YELLOW}WARN${NC} $*"; }
error() { echo -e "[$(date '+%H:%M:%S')] ${RED}ERROR${NC} $*"; }
success() { echo -e "[$(date '+%H:%M:%S')] ${GREEN}SUCCESS${NC} $*"; }

# Default values
DASHBOARD_TYPE="comprehensive"
OUTPUT_FILE=""
DATASOURCE_NAME="PostgreSQL"
DATABASE_NAME="postgres"
GRAFANA_URL=""
API_KEY=""

usage() {
    cat << EOF
Grafana Dashboard Generator for PostgreSQL

Usage: $0 [OPTIONS]

OPTIONS:
    -t, --type TYPE         Dashboard type: comprehensive, performance, security (default: comprehensive)
    -o, --output FILE       Output JSON file (default: stdout)
    -d, --datasource NAME   Grafana datasource name (default: PostgreSQL)
    -b, --database NAME     Database name for queries (default: postgres)
    -u, --url URL           Grafana URL for direct upload
    -k, --key KEY           Grafana API key for upload
    -h, --help              Show this help

DASHBOARD TYPES:
    comprehensive           Complete monitoring dashboard
    performance             Query and resource performance focus
    security                Security and audit monitoring
    connections             Connection and session monitoring
    maintenance             Vacuum, checkpoint, and maintenance

EXAMPLES:
    $0 --type comprehensive -o postgres-dashboard.json
    $0 --type performance --datasource "PostgreSQL Main"
    $0 --url http://grafana:3000 --key YOUR_API_KEY
    $0 --type security -o security-dashboard.json

GRAFANA INTEGRATION:
    To upload directly to Grafana, provide both --url and --key options.
    Otherwise, the JSON will be output to file or stdout for manual import.

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--type)
            DASHBOARD_TYPE="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -d|--datasource)
            DATASOURCE_NAME="$2"
            shift 2
            ;;
        -b|--database)
            DATABASE_NAME="$2"
            shift 2
            ;;
        -u|--url)
            GRAFANA_URL="$2"
            shift 2
            ;;
        -k|--key)
            API_KEY="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Validate dashboard type
case "$DASHBOARD_TYPE" in
    comprehensive|performance|security|connections|maintenance) ;;
    *)
        error "Invalid dashboard type: $DASHBOARD_TYPE"
        exit 1
        ;;
esac

# Generate comprehensive dashboard
generate_comprehensive_dashboard() {
    cat << EOF
{
  "dashboard": {
    "id": null,
    "title": "PostgreSQL Comprehensive Monitoring",
    "description": "Complete PostgreSQL monitoring dashboard generated by pgtools",
    "tags": ["postgresql", "database", "monitoring"],
    "timezone": "browser",
    "editable": true,
    "graphTooltip": 1,
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "timepicker": {
      "refresh_intervals": ["10s", "30s", "1m", "5m", "15m", "30m", "1h"],
      "time_options": ["5m", "15m", "1h", "6h", "12h", "24h", "2d", "7d", "30d"]
    },
    "refresh": "30s",
    "panels": [
      {
        "id": 1,
        "title": "Database Status",
        "type": "stat",
        "gridPos": {"h": 4, "w": 6, "x": 0, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT CASE WHEN pg_is_in_recovery() THEN 0 ELSE 1 END as status",
            "format": "table"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "mappings": [
              {"options": {"0": {"text": "Standby"}}, "type": "value"},
              {"options": {"1": {"text": "Primary"}}, "type": "value"}
            ],
            "color": {
              "mode": "thresholds",
              "thresholds": {
                "steps": [
                  {"color": "red", "value": null},
                  {"color": "green", "value": 1}
                ]
              }
            }
          }
        }
      },
      {
        "id": 2,
        "title": "Connections",
        "type": "stat",
        "gridPos": {"h": 4, "w": 6, "x": 6, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT count(*) as connections FROM pg_stat_activity",
            "format": "table"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "color": {
              "mode": "thresholds",
              "thresholds": {
                "steps": [
                  {"color": "green", "value": null},
                  {"color": "yellow", "value": 80},
                  {"color": "red", "value": 150}
                ]
              }
            }
          }
        }
      },
      {
        "id": 3,
        "title": "Database Size",
        "type": "stat",
        "gridPos": {"h": 4, "w": 6, "x": 12, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT pg_database_size('$DATABASE_NAME') as size_bytes",
            "format": "table"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "bytes"
          }
        }
      },
      {
        "id": 4,
        "title": "Cache Hit Ratio",
        "type": "stat",
        "gridPos": {"h": 4, "w": 6, "x": 18, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT ROUND(100.0 * sum(blks_hit) / NULLIF(sum(blks_hit + blks_read), 0), 2) as cache_hit_ratio FROM pg_stat_database WHERE datname = '$DATABASE_NAME'",
            "format": "table"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "percent",
            "color": {
              "mode": "thresholds",
              "thresholds": {
                "steps": [
                  {"color": "red", "value": null},
                  {"color": "yellow", "value": 90},
                  {"color": "green", "value": 95}
                ]
              }
            }
          }
        }
      },
      {
        "id": 5,
        "title": "Active Connections Over Time",
        "type": "timeseries",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 4},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT \$__time(now()), count(*) as total, count(*) FILTER (WHERE state = 'active') as active, count(*) FILTER (WHERE state = 'idle') as idle FROM pg_stat_activity",
            "format": "time_series"
          }
        ]
      },
      {
        "id": 6,
        "title": "Transaction Rate",
        "type": "timeseries",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 4},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT \$__time(now()), xact_commit as commits, xact_rollback as rollbacks FROM pg_stat_database WHERE datname = '$DATABASE_NAME'",
            "format": "time_series"
          }
        ]
      },
      {
        "id": 7,
        "title": "Top Tables by Size",
        "type": "table",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 12},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size FROM pg_tables WHERE schemaname NOT IN ('information_schema', 'pg_catalog') ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC LIMIT 10",
            "format": "table"
          }
        ]
      },
      {
        "id": 8,
        "title": "Lock Types",
        "type": "piechart",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 20},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT mode, count(*) FROM pg_locks GROUP BY mode",
            "format": "table"
          }
        ]
      },
      {
        "id": 9,
        "title": "Wait Events",
        "type": "table",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 20},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT wait_event_type, wait_event, count(*) as processes FROM pg_stat_activity WHERE wait_event IS NOT NULL GROUP BY wait_event_type, wait_event ORDER BY processes DESC LIMIT 10",
            "format": "table"
          }
        ]
      }
    ]
  }
}
EOF
}

# Generate performance-focused dashboard
generate_performance_dashboard() {
    cat << EOF
{
  "dashboard": {
    "id": null,
    "title": "PostgreSQL Performance Monitoring",
    "description": "Query and resource performance monitoring dashboard",
    "tags": ["postgresql", "performance", "queries"],
    "timezone": "browser",
    "editable": true,
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s",
    "panels": [
      {
        "id": 1,
        "title": "Slow Queries (pg_stat_statements required)",
        "type": "table",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT calls, ROUND(total_exec_time::numeric, 2) as total_time_ms, ROUND(mean_exec_time::numeric, 2) as mean_time_ms, LEFT(query, 100) as query_snippet FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10",
            "format": "table"
          }
        ]
      },
      {
        "id": 2,
        "title": "Buffer Cache Hit Ratio",
        "type": "timeseries",
        "gridPos": {"h": 6, "w": 12, "x": 0, "y": 8},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT \$__time(now()), ROUND(100.0 * sum(blks_hit) / NULLIF(sum(blks_hit + blks_read), 0), 2) as cache_hit_ratio FROM pg_stat_database",
            "format": "time_series"
          }
        ]
      },
      {
        "id": 3,
        "title": "Checkpoint Activity",
        "type": "timeseries",
        "gridPos": {"h": 6, "w": 12, "x": 12, "y": 8},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT \$__time(now()), checkpoints_timed, checkpoints_req FROM pg_stat_bgwriter",
            "format": "time_series"
          }
        ]
      },
      {
        "id": 4,
        "title": "Table I/O Statistics",
        "type": "table",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 14},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT schemaname, tablename, heap_blks_read, heap_blks_hit, ROUND(100.0 * heap_blks_hit / NULLIF(heap_blks_hit + heap_blks_read, 0), 2) as cache_hit_ratio FROM pg_statio_user_tables WHERE heap_blks_read + heap_blks_hit > 0 ORDER BY heap_blks_read + heap_blks_hit DESC LIMIT 15",
            "format": "table"
          }
        ]
      }
    ]
  }
}
EOF
}

# Generate security monitoring dashboard
generate_security_dashboard() {
    cat << EOF
{
  "dashboard": {
    "id": null,
    "title": "PostgreSQL Security Monitoring",
    "description": "Security and audit monitoring dashboard",
    "tags": ["postgresql", "security", "audit"],
    "timezone": "browser",
    "editable": true,
    "time": {
      "from": "now-24h",
      "to": "now"
    },
    "refresh": "5m",
    "panels": [
      {
        "id": 1,
        "title": "Active Superusers",
        "type": "table",
        "gridPos": {"h": 6, "w": 12, "x": 0, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT rolname, rolsuper, rolcreaterole, rolcreatedb, rolcanlogin FROM pg_roles WHERE rolsuper = true ORDER BY rolname",
            "format": "table"
          }
        ]
      },
      {
        "id": 2,
        "title": "Failed Authentication Attempts",
        "type": "stat",
        "gridPos": {"h": 6, "w": 12, "x": 12, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT count(*) as failed_logins FROM pg_stat_activity WHERE state = 'idle' AND query = '<authentication failed>'",
            "format": "table"
          }
        ]
      },
      {
        "id": 3,
        "title": "Database Permissions Audit",
        "type": "table",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 6},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT datname, datacl FROM pg_database WHERE datacl IS NOT NULL ORDER BY datname",
            "format": "table"
          }
        ]
      },
      {
        "id": 4,
        "title": "Long Running Transactions",
        "type": "table",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 14},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT pid, usename, application_name, client_addr, EXTRACT(EPOCH FROM (now() - xact_start))::int as duration_seconds, LEFT(query, 100) as query_snippet FROM pg_stat_activity WHERE xact_start < now() - interval '1 hour' AND state != 'idle' ORDER BY duration_seconds DESC",
            "format": "table"
          }
        ]
      }
    ]
  }
}
EOF
}

# Generate connections monitoring dashboard
generate_connections_dashboard() {
    cat << EOF
{
  "dashboard": {
    "id": null,
    "title": "PostgreSQL Connections Monitoring",
    "description": "Connection and session monitoring dashboard",
    "tags": ["postgresql", "connections", "sessions"],
    "timezone": "browser",
    "editable": true,
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s",
    "panels": [
      {
        "id": 1,
        "title": "Connection Count by State",
        "type": "piechart",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT state, count(*) FROM pg_stat_activity GROUP BY state",
            "format": "table"
          }
        ]
      },
      {
        "id": 2,
        "title": "Connections by Database",
        "type": "bargraph",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT datname, count(*) FROM pg_stat_activity WHERE datname IS NOT NULL GROUP BY datname ORDER BY count(*) DESC",
            "format": "table"
          }
        ]
      },
      {
        "id": 3,
        "title": "Connection Pool Analysis",
        "type": "table",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 8},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT application_name, COUNT(*) as total_connections, COUNT(*) FILTER (WHERE state = 'active') as active, COUNT(*) FILTER (WHERE state = 'idle') as idle, COUNT(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction FROM pg_stat_activity WHERE application_name IS NOT NULL GROUP BY application_name ORDER BY total_connections DESC",
            "format": "table"
          }
        ]
      }
    ]
  }
}
EOF
}

# Generate maintenance monitoring dashboard
generate_maintenance_dashboard() {
    cat << EOF
{
  "dashboard": {
    "id": null,
    "title": "PostgreSQL Maintenance Monitoring",
    "description": "Vacuum, analyze, and maintenance operations monitoring",
    "tags": ["postgresql", "maintenance", "vacuum"],
    "timezone": "browser",
    "editable": true,
    "time": {
      "from": "now-24h",
      "to": "now"
    },
    "refresh": "5m",
    "panels": [
      {
        "id": 1,
        "title": "Tables Needing Vacuum",
        "type": "table",
        "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT schemaname, tablename, n_dead_tup, n_live_tup, ROUND(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_tuple_ratio, last_autovacuum FROM pg_stat_user_tables WHERE n_dead_tup > n_live_tup * 0.1 ORDER BY dead_tuple_ratio DESC LIMIT 10",
            "format": "table"
          }
        ]
      },
      {
        "id": 2,
        "title": "Autovacuum Activity",
        "type": "timeseries",
        "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT \$__time(now()), COUNT(*) as autovacuum_processes FROM pg_stat_activity WHERE query LIKE 'autovacuum:%'",
            "format": "time_series"
          }
        ]
      },
      {
        "id": 3,
        "title": "Bloated Tables",
        "type": "table",
        "gridPos": {"h": 8, "w": 24, "x": 0, "y": 8},
        "targets": [
          {
            "datasource": "$DATASOURCE_NAME",
            "rawSql": "SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size, n_dead_tup, last_vacuum, last_autovacuum FROM pg_stat_user_tables WHERE n_dead_tup > 10000 ORDER BY n_dead_tup DESC LIMIT 15",
            "format": "table"
          }
        ]
      }
    ]
  }
}
EOF
}

# Upload dashboard to Grafana
upload_to_grafana() {
    local dashboard_json="$1"
    
    if [[ -z "$GRAFANA_URL" || -z "$API_KEY" ]]; then
        return 0
    fi
    
    log "Uploading dashboard to Grafana: $GRAFANA_URL"
    
    local temp_file=$(mktemp)
    echo "$dashboard_json" > "$temp_file"
    
    local response
    if response=$(curl -s -H "Authorization: Bearer $API_KEY" \
                       -H "Content-Type: application/json" \
                       -X POST "$GRAFANA_URL/api/dashboards/db" \
                       -d @"$temp_file" 2>&1); then
        
        if echo "$response" | grep -q '"status":"success"'; then
            success "Dashboard uploaded successfully to Grafana"
            local dashboard_url=$(echo "$response" | grep -o '"url":"[^"]*"' | cut -d'"' -f4)
            [[ -n "$dashboard_url" ]] && log "Dashboard URL: $GRAFANA_URL$dashboard_url"
        else
            error "Failed to upload dashboard to Grafana"
            echo "Response: $response"
        fi
    else
        error "Failed to connect to Grafana API"
        echo "Response: $response"
    fi
    
    rm -f "$temp_file"
}

# Main execution
main() {
    log "Generating $DASHBOARD_TYPE PostgreSQL dashboard for Grafana"
    
    local dashboard_json
    case "$DASHBOARD_TYPE" in
        comprehensive)
            dashboard_json=$(generate_comprehensive_dashboard)
            ;;
        performance)
            dashboard_json=$(generate_performance_dashboard)
            ;;
        security)
            dashboard_json=$(generate_security_dashboard)
            ;;
        connections)
            dashboard_json=$(generate_connections_dashboard)
            ;;
        maintenance)
            dashboard_json=$(generate_maintenance_dashboard)
            ;;
    esac
    
    # Output to file or stdout
    if [[ -n "$OUTPUT_FILE" ]]; then
        echo "$dashboard_json" > "$OUTPUT_FILE"
        success "Dashboard JSON written to: $OUTPUT_FILE"
    else
        echo "$dashboard_json"
    fi
    
    # Upload to Grafana if configured
    upload_to_grafana "$dashboard_json"
    
    if [[ -z "$OUTPUT_FILE" && -z "$GRAFANA_URL" ]]; then
        log "Dashboard JSON output to stdout. Save to file and import to Grafana manually."
    fi
}

main "$@"